function [ PCs, criteria ] = PC_reliability_checker_mini2p(data,...
    bin_size, coords, bout_duration, cohens_d)
%% PC_reliability_checker
%-------------------------------------------------------------------------%
%   This function finds place cells using the following three criteria, as
%   defined by Zong et al., 2022:
%
%   (1) Spatial information score > the 85th percentile of a shuffled
%   distribution
%   (2) Pearson's correlation between random bouts of the session passes a
%   cohen's d threshold
%   (3) At least one place fied, defined as activity elevated 40% above the 
%   mean in at least 2 square bins
%
%   Inputs:
%   'activityMap' is a 3D array where each slice along the third dimension 
%    contains the binned activity data.
%   'save_flag' is a boolean flag indicating whether to save data to the 
%    current directory. If 'save_flag' is not provided or empty, it defaults to 1 (true).
%   'shuffle_data' is a boolean flag indicating whether to shuffle actual 
%    data. If 'shuffle_data' is not provided or empty, it defaults to 0 (false).
%
%   Outputs:
%   'PCs' is a vector of indices of the place cells.
%   'FWHM' is a vector of the full width at half maximum (FWHM) of the 
%    place cells.
%   'params' is a structure containing the parameters used in the function.
%
%   Written by MJG 06/18/2021 // Last updated by NSW 06/01/2023
%
%   See also UIGETFILE, IMPORTDATA, RANDPERM, CORRCOEF, RANKSUM, FIT, MEAN, STD, SAVEAS.
%-------------------------------------------------------------------------%
if nargin < 4 || isempty(bout_duration)
    bout_duration = 100; % number of frames to compare for consistency
end
if nargin < 4 || isempty(cohens_d)
    cohens_d = 0.35; % cohen's d threshold for consistency
end

% Parameters
nShuffles = 1000;
activity = data.DFF_transients;
x = coords(:,1);
y = coords(:,2);
[nCells, nFrames] = size(activity);

% Binning
xEdges = floor(min(x)):bin_size:ceil(max(x));
yEdges = floor(min(y)):bin_size:ceil(max(y));
nBinsX = length(xEdges)-1;
nBinsY = length(yEdges)-1;
nBins = nBinsX * nBinsY;
[~, ~, xBin] = histcounts(x, xEdges);
[~, ~, yBin] = histcounts(y, yEdges);

% Occupancy
occupancyMap = accumarray([yBin(xBin>0 & yBin>0), xBin(xBin>0 & yBin>0)], 1, [nBinsY, nBinsX]);
occupancyFlat = reshape(occupancyMap, [nBins, 1]);
p_i = occupancyFlat / sum(occupancyFlat);

% Bin index for each frame
disp('Getting spatial information score...')
binIdx = zeros(nFrames, 1);
for i = 1:nFrames
    if xBin(i) > 0 && yBin(i) > 0
        binIdx(i) = sub2ind([nBinsY, nBinsX], yBin(i), xBin(i));
    end
end

% Spatial information
activityFlat = zeros(nBins, nCells);
for c = 1:nCells
    tempMap = accumarray(binIdx(binIdx>0), activity(c, binIdx>0), [nBins, 1]);
    r_i = zeros(nBins,1);
    valid = occupancyFlat > 0;
    r_i(valid) = tempMap(valid) ./ occupancyFlat(valid);
    activityFlat(:,c) = r_i;
end

spatialInfo = zeros(1, nCells);
for c = 1:nCells
    r_i = activityFlat(:,c);
    r_i(r_i==0) = eps;
    r_bar = sum(p_i .* r_i);
    spatialInfo(c) = sum(p_i .* (r_i / r_bar) .* log2(r_i / r_bar));
end

% Shuffled SI
shuffledSI = zeros(nShuffles, nCells);
for s = 1:nShuffles
    for c = 1:nCells
        shuffled_trace = circshift(activity(c,:), randi(nFrames));
        tempMap = accumarray(binIdx(binIdx>0), shuffled_trace(binIdx>0), [nBins, 1]);
        r_i = zeros(nBins, 1);
        valid = occupancyFlat > 0;
        r_i(valid) = tempMap(valid) ./ occupancyFlat(valid);
        r_i(r_i==0) = eps;
        r_bar = sum(p_i .* r_i);
        shuffledSI(s,c) = sum(p_i .* (r_i / r_bar) .* log2(r_i / r_bar));
    end
end

sigSI = spatialInfo > prctile(shuffledSI, 85);

% Consistency via Cohen's d
disp('Computing consistency using Cohen''s d...');
nBouts = 10; %ceil(nFrames/bout_duration);
reliability = zeros(1, nCells);

for c = 1:nCells
    d_values = zeros(nBouts, 1);
    for b = 1:nBouts
        idxA = sort(randsample(nFrames - bout_duration + 1, 1)) : ...
               sort(randsample(nFrames - bout_duration + 1, 1)) + bout_duration - 1;
        idxB = sort(randsample(nFrames - bout_duration + 1, 1)) : ...
               sort(randsample(nFrames - bout_duration + 1, 1)) + bout_duration - 1;

        % Get spatial response vectors for each bout
        aBins = binIdx(idxA); aVals = activity(c, idxA); 
        bBins = binIdx(idxB); bVals = activity(c, idxB);

        aAct = accumarray(aBins(aBins>0), aVals(aBins>0), [nBins, 1]);
        bAct = accumarray(bBins(bBins>0), bVals(bBins>0), [nBins, 1]);

        % Normalize by occupancy
        diff_mean = mean(aAct) - mean(bAct);
        pooled_std = sqrt((std(aAct)^2 + std(bAct)^2) / 2);
        d_values(b) = diff_mean / pooled_std;
    end

    % Take mean Cohen's d across bouts and compare to threshold
    reliability(c) = mean(abs(d_values), 'omitmissing');
end

sigRel = reliability > cohens_d;

% Place field contiguity
disp('Checking for place fields...')
hasPlaceField = false(1, nCells);
thresholdFrac = 0.4;

for c = 1:nCells
    rMap = reshape(activityFlat(:,c), [nBinsY, nBinsX]);
    rThresh = mean(rMap(:)) + thresholdFrac * mean(rMap(:));
    above = rMap > rThresh;

    % Check for 2x2 block
    fieldDetected = false;
    for i = 1:(nBinsY - 1)
        for j = 1:(nBinsX - 1)
            block = above(i:i+1, j:j+1);
            if all(block(:))
                fieldDetected = true;
                break
            end
        end
        if fieldDetected, break; end
    end
    hasPlaceField(c) = fieldDetected;
end

% Final criteria
criteria = false(nCells, 3);  % [spatialInfo, reliability, placeField]
criteria(:,1) = sigSI(:);
criteria(:,2) = sigRel(:);
criteria(:,3) = hasPlaceField(:);

PCs = sigSI & sigRel & hasPlaceField;
fprintf('Identified %d place cells out of %d.\n', sum(PCs), nCells);

x = 2;
end